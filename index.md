---
# Feel free to add content and custom Front Matter to this file.
# To modify the layout, see https://jekyllrb.com/docs/themes/#overriding-theme-defaults

layout: home
title: Содержание
---
1.	[Стандарт **Unicode**](#uni)

1. 	[Кодировка **UTF-16**](#utf16)

1.	[Кодировка **UTF-8**](#utf8)

1.	[**UTF-8** vs **UTF-16**: преимущества и недостатки](#vs)

# <a name="uni"></a>Стандарт **Unicode**

**Unicode** – это промышленный стандарт кодирования для единого универсального цифрового представления символов всех письменностей мира, а также описания всех известных на сегодня областей знаний с используемыми в них обозначениями. 

Стандарт включает универсальный набор символов **UCS** (Universal Character Set) и набор кодировок **UTF** (Unicode Transformation Format), но часто, говоря о **Unicode**, имеют в виду именно первую часть стандарта – универсальный набор символов. Этот набор символов описывается кодовой таблицей, которая ставит в соответствие хранимым символам уникальные номера позиций в таблице. 

Номера будем называть кодовыми точками, они описываются неотрицательными целыми числами в шестнадцатеричной системе счисления с префиксом U+, например, буква ‘F’ имеет код U+0046. Эта таблица хранит символы всех современных алфавитов, устаревших и даже мертвых языков, иероглифы, специальные знаки, такие как элементы формул, музыкальные знаки, знаки валют и даже эмодзи.

## Предпосылки и история

Одной из самых ранних и употребимых кодовых таблица была **ASCII** (American Standart Code for Information Interchange), разработанная в США в 1963 году. В исходном семибитном варианте **ASCII** содержала заглавные и строчные буквы латинского алфавита, цифры, знаки препинания и управляющие символы, она представлена в таблице 1. Например, в этой кодовой таблице символ ‘F’ имеет номер 100 0110<sub>2</sub> или 46<sub>16</sub>. Аббревиатуры используются в ней для обозначения управляющих и непечатных символов, не имеющих графического представления. Первые 128 символов кодировки **ASCII** были перенесены в **Unicode** в неизменном виде, их номера в двух кодовых таблицах совпадают. 

Позже стал использоваться 8 битный вариант **ASCII**, что привело к увеличение таблицы вдвое. Вторая половина таблицы из 128 символов использовалась для хранения национальных алфавитов. Небольшой объем таблицы не позволял хранить сразу несколько национальных алфавитов, что привело к появлению различных национальных вариантов таблицы **ASCII**. Такой подход исключал представления многоязыковых текстов и создавал существенные трудности при попытке использовать текст из другой кодовой таблицы. Кроме того, нашлись языки, количество букв в алфавитах которых превышало количество доступных позиций во второй половине таблицы. Также возникали сложности, связанные с использованием шрифтов, так как для каждой национальной кодировки создавался свой шрифт, даже при условии, что многие символы в разных национальных кодировках совпадали. Неоспоримым плюсом **ASCII** и других восьмибитных кодировок является фиксированная длина представления каждого символа и крайняя экономичность.

### Таблица 1. Кодовая таблица ASCII

!["ASCII"](/images/ascii.png)

С появлением и развитием Интернет, нарастающими процессами глобализации и интеграции в обществе возникла необходимость в создании единой кодовой таблицы, включающей все национальные алфавиты, независимой от платформ, операционных систем, государств, в которых она используется. Такая таблица позволила бы воспроизвести любой текст в исходном виде в любой точке мира и на любом компьютере.

В 1991 году была создана некоммерческая организация [Unicode Consortium][unicode-org], результатом работы которой и стал **Unicode**. Первая версия стандарта вышла в октябре 1991 года. Стандарт постоянно дополняется и совершенствуется, при этом символы, которые ранее добавленные в кодовую таблицу никогда не меняют своих позиций в последующих версиях. Последняя 12 версия стандарта была выпущена в марте 2019 года. Очевидно, что кодовая таблица для хранения всех (или подавляющего большинства) символов, используемых современной цивилизацией, должна иметь огромный объем. Первая версия **Unicode** была описана как таблица с фиксированным размером для хранения одной кодовой точки в 16 бит, то есть общее количество кодовых точек 2<sup>16</sup> (64 536). Позже, когда было принято решение хранить все известные символы, в том числе и устаревшие, возникла необходимость расширить кодовое пространство. В настоящее время номера в кодовой таблице располагаются в диапазоне от U+00000 до U+10FFFF. 


## Плоскости Unicode

Для удобства кодовая таблица была разделена на плоскости. В каждой плоскости последние 4 разряда изменяются от 0000 до FFFF, а номера первых разрядов дают номер плоскости и изменяются от 0 до 10<sub>16</sub>. Каждая плоскость состоит из 2<sup>16</sup>=65 536 кодовых точек, а вся таблица из 17\*65 536, но часть плоскостей и отдельных кодовых точек в настоящее время не используется. Номера и названия плоскостей представлены в таблице 2.

### Таблица 2. Плоскости **Unicode**

| Плоскость       | Английское название            | Аббревиатура  | Русское название                 |
| :--------------:|:------------------------------:|:-------------:|:--------------------------------:|
| 0               | Basic Multilangual Plane       | BMP           | Основная многоязычная плоскость  |
| 1               | Supplementary Multilangual Plane | SMP    | Дополнительная многоязычная плоскость |
| 2             | Supplementary Ideographic Plane | SIP    | Дополнительная идеографическая плоскость |
| 3             | Tertiary Ideographic Plane      | TIP    | Третичная идеографическая плоскость      |
| 4-13          | не используются                                                       |
| 14       | Supplementary Special-purpose Plane | SSP  | Специализированная дополнительная плоскость |
|15 |Supplementary Private Use Area-A | SPUA-A  | Дополнительная область для частного использования A |
|15 |Supplementary Private Use Area-B | SPUA-B  | Дополнительная область для частного использования B |

Наиболее употребимой частью **Unicode** является нулевая основная многоязычная плоскость (**BMP**), ее структура представлена на рисунке 1. Она содержит символы большинства современных письменностей, спецсимволы, китайско-японские иероглифы и корейские буквы (далее ККЯ). В нулевой плоскости адреса с U+0D800 по U+0DFFF отведены для нужд кодировки **UTF-16**, под так называемые суррогатные пары. Они описаны в разделе, посвященному кодировке **[UTF-16](#utf16)**. В дальнейшем, в случае если кодовая точка описывается четырехразрядным числом, то имеется в виду именно плоскость **BMP**, во всех остальных случаях кодовая точка будет описываться пятиразрядным числом.

![Рисунок 1. Основная многоязычная плоскость **Unicode**](/images/bmp.png)

### Рисунок 1. Основная многоязычная плоскость **Unicode**

Плоскость 1 (дополнительная многоязычная плоскость) содержит символы исторических (устаревших) письменностей, музыкальные и математические символы. 

Плоскость 2 отведена под не вошедшие в плоскость 0 иероглифы ККЯ, плоскость 3 – редко используемые китайские иероглифы и исторические формы китайского письма. Плоскости с 4 по 13 в настоящее время не используются. 

Плоскость 14 отведена для тегов и символов, используемых по особому назначению. Некоторые области адресов отведены для частного использования, это область от U+0E000 до U+0F8FF в основной многоязычной плоскости и плоскости 15 и 16 целиком. 

## Алгоритмы нормализации и двунаправленное письмо

Представление символов в **Unicode** не является абсолютно однозначным. Символы в **Unicode** подразделяются на базовые и комбинируемые. Комбинируемые символы указываются за базовыми, к которым они применяются, и изменяют их отображение. Например, русскую букву ‘Й’ можно представить в виде символа ‘И’ (U+0418) и комбинируемого символа '  &#x0306; ' (U+0306). В результате сложилась ситуация, когда одну и туже букву можно записать и как один символ и как сочетание базового и комбинируемого символов, кроме того, к одному символу может применяться сразу несколько знаков, и они могут упоминаться в любом порядке. Это затрудняет побайтное сравнение строк, содержащих такие символы. Для преодоления подобных трудностей в **Unicode** были описаны алгоритмы нормализации, которые позволяют приводить тексты к некоторому стандартному виду. Для нормализации используется декомпозиция – разложение символов на составляющие согласно строгим правилам и композиция – соединение базовых и комбинируемых символов в один. Подробнее алгоритмы нормализации описаны на [habr][habr]. 

Другой сложностью, связанной с использованием **Unicode**, является двунаправленное письмо. Стандарт Unicode поддерживает направление письма слева направо, справа налево, а также двунаправленное письмо. При этом многие текстовые редакторы, поддерживающие Unicode, не поддерживают двунаправленное письмо.

## Кодировки

Кодовые точки в таблице **Unicode** правильно будет рассматривать как абстрактные числа, за их представление в памяти компьютера отвечают системы кодирования или кодировки. 

Кодировка – это способ хранения символов в виде последовательности битов. Для кодовой таблицы **Unicode** было предложено несколько кодировок: **UTF-8**, **UTF-16** (**UTF-16BE** и **UTF-16LE**), **UTF-32**, **EUC**.

Кодировки семейства **UTF** значительно отличаются друг от друга. Кодировка **UTF-32** является кодировкой с постоянной длинной, в ней на описание каждого символа расходуется 4 байта. Очевидно, что такое представление является крайне неэкономичным: файл, который в **ASCII** занимал N байт теперь потребует 4\*N. 

В отличие от **UTF-32** кодировки **UTF-8** и **UTF-16** относятся к кодировкам с переменной длиной, цифры 8 и 16 в их названиях обозначают минимальное количество бит для описания символа. Это означает, что на описание символа в кодировке **UTF-8** может быть затрачено 8, 16, 24 или 32 бита, но при этом в **UTF-16** только 16 или 32 бита. 

Как пользоваться такой кодировкой? Если описание одного символа не имеет постоянной длины, то как понять, когда заканчивается описание одного символа и начинается описание следующего? В следующих разделах рассмотрим использование кодировок **[UTF-16](#utf16)** и **[UTF-8](#utf8)** подробнее, а также их [преимущества и недостатки](#vs).

# <a name="utf16"></a>Кодировка **UTF-16**

Кодировка **UTF-16** описывает способ кодирования символов **Unicode** в виде 16 битных или 32 битных последовательностей. 

Кодировка позволяет кодировать символы в диапазонах с U+0000 по U+D7FF и с U+E000 по U+10FFFF, но как уже упоминалось раннее оставшийся диапазон с U+D800 по U+DFFF является служебным и за кодовыми точками из него не закреплено символов. Он зарезервирован для нужд кодировки **UTF-16**. 

Символы из диапазонов с U+0000 по U+D7FF и c U+E000 по U+FFFF в **UTF-16** представляются 16 битными последовательностями. Последнее доступное для кодирования в 16 битах значение U+FFFF в двоичном виде имеет представление 11111111 11111111<sub>2</sub>, очевидно, на этом выразительные способности 16 бит исчерпаны. 

Символы из диапазона U+10000 по U+10FFFF представляются 32 битными последовательностями, их еще называют суррогатными парами. Кодирование с использованием 16 битных и 32-битных последовательностей существенно различается. Поэтому рассмотрим для начала кодирование 16 битными последовательностями.

Если в кодировке **ASCII** для представления символа ‘F’ достаточно было 7 бит (8 в восьмибитном варианте **ASCII**), то теперь в **UTF-16** на это придется затратить 16 бит: 

00000000 01000110<sub>2</sub>. 

Нетрудно заметить, что последние семь бит в **UTF-16** совпадают с кодом буквы в **ASCII**. Добавление еще одного байта расширяет пространство символов, которые можно описать с использованием 16 бит, до всех символов основной многоязычной плоскости. С другой стороны, возникает вопрос: почему байт был добавлен в начале, а не в конце?
 Вместо приведенной выше последовательности бит можно было бы записать 

 01000110 00000000<sub>2</sub>. 

 И действительно, такая кодировка тоже используется. Это способ называется Big Endian, так как код хранится в старшем байте, для этой кодировке используют обозначение **UTF-16BE**.  Первый способ, когда нули дописываются слева, называется Little Endian, потому что в этом случае код хранится в младшем байте, для него используется обозначение **UTF-16LE**. Здесь при дальнейшем рассмотрении мы всегда будем иметь в виду **UTF-16LE**.


Рассмотрим теперь представление символов **Unicode** из диапазона с U+10000 по U+10FFFF в виде суррогатных пар. Суррогатные пары формируются согласно следующей схеме:

1.	Из исходной кодовой точки вычитается U+10000. В результате получается 	
    значение от U+00000 до U+FFFFF, которое можно записать в 20 битах. Получившаяся последовательность делится пополам по 10 бит.
2.	Старшие 10 бит дополняются слева нулями до 16 бит и суммируются с D800<sub>16</sub>, результат дает первые 16 бит – лидирующее слово суррогатной пары. Значение будет располагаться в диапазоне от D800<sub>16</sub> до DBFF<sub>16</sub>.
3.	Младшие 10 бит также дополняются слева нулями до 16 бит и суммируются с DС00<sub>16</sub>, результат дает вторые 16 бит – последующее слово суррогатной пары. Значение будет располагаться в диапазоне от DС00<sub>16</sub> до DFFF<sub>16</sub>.


Рассмотрим пример вычисления суррогатной пары для кодовой точки U+3AF04.
1.	После вычитания из U+3AF04 кода U+10000 получаем U+2AF04. Приводим получившееся значение к 
	двоичному виду:

	| 2 | A | F | 0 | 4 |
	|:-:|:-:|:-:|:-:|:-:|
	| 0010 | 1010 | 11  \|  11 | 0000 | 0100 |

	Делим получившуюся последовательность бит пополам:

	|первые 10 бит|вторые 10 бит|
	|:----:|:-----:| 
	| 0010 1010 11 | 11 0000 0100 |

2.	К старшим 10 битам приписываем слева 6 нулей, получаем 0000 0000 1010 1011<sub>2</sub>, 
	складываем с D800<sub>16</sub> (1101 1000 0000 0000<sub>2</sub>), получаем 1101 1000 1010 1011<sub>2</sub> (D8AB<sub>16</sub>):

	|:------|:-------------------:|:----:|
	|слагаемое 1 | 0000 0000 1010 1011<sub>2</sub> | 00AB<sub>16</sub> |
	|слагаемое 2 | 1101 1000 0000 0000<sub>2</sub> | D800<sub>16</sub> |
	|сумма| 1101 1000 1010 1011<sub>2</sub> | D8AB<sub>16</sub> |

3.	К младшим 10 битам приписываем слева 6 нулей, получаем 0000 0011 0000 0100<sub>2</sub>,
	складываем с DС00<sub>16</sub> (1101 1100 0000 0000<sub>2</sub>), получаем 1101 1111 0000 0100<sub>2</sub> (DF04<sub>16</sub>):

	|:------|:-------------------:|:----:|
	|слагаемое 1 |  0000 0011 0000 0100<sub>2</sub> | 0304<sub>16</sub> |
	|слагаемое 2 |  1101 1100 0000 0000<sub>2</sub> | DC00<sub>16</sub> |
	| сумма|  1101 1111 0000 0100<sub>2</sub> | DF04<sub>16</sub> |

В результате получим код в **UTF-16** D8AB DF04<sub>16</sub>.

Как понять с каким представлением (16 или 32 битным) мы имеем дело при работе с очередными 16 битами? Это всегда можно определить по первым 6 битам. Так как при кодировании точек из диапазона с U+0000 по U+D7FF первые 6 бит изменяются в диапазоне от 0000 00 до 1101 01. При кодировании символов из диапазона U+E000 до U+FFFF первые 6 бит изменяются в диапазоне 1110 00 до 1111 11. У первого слова суррогатной пары первые 6 бит имеют значение 1101 10, у второго – 1101 11. Эти диапазоны не имеют общих точек, таким образом описанное представление является однозначным, оно также описано в таблице 3.

### Таблица 3. Диапазоны кодов, используемые для различных представлений в **UTF-16**

| Диапазон кодов | Первые 6 бит | Представление |
|:-------------------------:|:------------:|:-------------:|
|0000..D7FF|0000 00 .. 1101 01| 16-битное слово |
|D800..DBFF|1101 10| первое слово суррогатной пары|
|DC00..DFFF|1101 11| второе слово суррогатной пары|
|E000..FFFF|1110 00 .. 1111 11| 16-битное слово|

Все 20 битные последовательности кодируют 2<sup>20</sup> кодовых точек, 16 битные  -  2<sup>16</sup>, но из них исключается диапазон U+D800 до U+DFFF – это 2048 точек, итого 2<sup>20</sup>+2<sup>16</sup> – 2048 = 1 112 064 символов можно закодировать с использование кодировки **UTF-16**.

Представим, что у нас есть файл или поток, из которого нужно прочитать последовательность символов в кодировке **UTF-16**. Как понять какой вариант  **BE** или **LE**  используется? Для этого в начале файла добавляются дополнительные специальные двухбайтовые метки порядка байтов **BOM** (Byte Order Mark). Первые два байта U+FEFF указывают, что данные в формате **BE**, если U+FFFE - то это **LE**. Эти коды не используются в **Unicode** для кодирования символов, поэтому принять их за коды символов нельзя. Если кодировка для файла указана явно (**UTF-16LE** или **UTF-16BE**), то в этом случае метку можно не указывать.

# <a name="utf8"></a>Кодировка **UTF-8**

**UTF-8** позволяет кодировать символы **Unicode** в 8, 16, 24 или 32 битах. На сегодняшний день этот стандарт является доминирующем в Интернет. Формат был разработан в 1992 году Кеном Томпсоном и Робом Пайком.

Кодирование с использованием **UTF-8** сходно с кодированием с использованием **UTF-16**. Процесс кодирования можно разбить на 2 основных этапа:

1.	Определение количества восьмибитных слов, необходимых для кодирования символа.
2.	Запись кодовой точки в заданное количество восьмибитных слов, для этого необходимо:
	+	заполнить маркировочные биты;
	+	записать кодовую точку в оставшиеся биты, начиная с последнего;
	+	оставшиеся биты заполнить нулями.

Маркировочные биты предназначены для того, чтобы помечать первые восьмибитные слова при кодировке, с указанием на то, сколько слов будет использоваться, а также последующие слова.

Теперь рассмотрим эти этапы подробнее. Определить количество восьмибитных слов необходимое для кодирования символа можно по таблице 4. В таблице представлены диапазоны кодовых точек таблицы **Unicode**, количество слов необходимое для записи в **UTF-8**, а также максимальное количество бит, необходимое для записи максимального числа в диапазоне. 

### Таблица 4. Диапазоны символов по количеству восьмибитных слов для их кодирования

| Диапазон номеров символов |	Требуемое количество восьмибитных слов | Максимальное количество бит |
|:-------------------------:|:----------------------------------------:|:---------------------------:|
| U+0000..U+007F	| 1 |7  |
| U+0080..U+07FF	| 2 |11 |
| U+0800..U+FFFF	| 3 |16 |
| U+10000..U+10FFFF	| 4 |21 |

Символы, которые кодируются одном словом, представимы 7 битами, при записи числа в 8 битах старший бит в этом диапазоне всегда равен 0. Например символ ‘F’ можно представить также как и в **ASCII**:

01000110<sub>2</sub>. 

Поэтому, если символ представляется одним восьмибитным словом, то оно всегда начинается с нулевого бита. Файл, состоящий из первых 128 символов кодовой таблицы **Unicode** в этой кодировке, совместим с **ASCII**.

В случае, когда для кодирования символа необходимо использовать 2 восьмибитных слова, первые три бита ведущего слова устанавливаются в 110<sub>2</sub>, а первые два бита второго слова устанавливаются в 10<sub>2</sub>.

Если же кодовую точку необходимо разместить в 3 или 4 восьмибитных словах, то первые биты первых слов маркируются 1110<sub>2</sub> и 11110<sub>2</sub> соответственно, а все последующие слова маркируются двумя первыми битами 10<sub>2</sub>. В таблице 5 представлены шаблоны для представления кодовых точек в **UTF-8** в виде 1, 2, 3 и 4 восьмибитных слов. Столбец «Количество значащих бит» показывает сколько значащих бит остается в представлении за вычетом маркировочных, этот столбец полностью совпадает со столбцом «Максимальное количество бит» таблицы 4, что объясняет выбор диапазонов для представления кодовых точек в кодировке **UTF-8**.

### Таблица 5. Шаблоны кодирования для различного количества восьмибитных слов

| Количество слов	| Количество значащих бит | Шаблон |
|:-----------------------------:|:-----------------------:|:------|
|1 | 7 | 0xxxxxxx |
|2 | 11 | 110xxxxx 10xxxxxx |
|3 | 16 | 1110xxxx 10xxxxxx 10xxxxxx |
|4 | 21 | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

В качестве примера рассмотрим процесс кодирования символа U+3AF04 в **UTF-8**.

1.	Согласно таблице 4, символ U+3AF04 принадлежит последнему диапазону, для кодировки этого символа 
	потребуется 4 байта.

2.	Запишем слово в двоичной системе счисления и применим схему кодирования, описанную выше.

	| 3 | A | F | 0 | 4 |
	|:-:|:-:|:-:|:-:|:-:|
	| 0011 | 1010 | 1111 | 0000 | 0100 |

	1.	Запишем шаблон и подставим в него маркировочные биты, 
		оставшиеся позиции заполним x:

		| байт 1 | байт 2 | байт 3 | байт 4 |
		|:-----:|:-----:|:-----:|:-----:|
		| 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx| 

	1. 	Запишем биты символа на оставшиеся позиции начиная с конца. Распределение битов символа 
		по битам кода будет иметь вид:

		| байт 1 | байт 2 | байт 3 | байт 4 |
		|:-----:|:-----:|:-----:|:-----:|
		| 00 | 11  1010 | 1111  00 | 00  0100 |	

		В результате получим следующее представление кодовой точки, в котором остается незаполненным один бит:

		| байт 1 | байт 2 | байт 3 | байт 4 |
		|:-----:|:-----:|:-----:|:-----:|
		| 1111 0x00 | 1011 1010 | 1011 1100 | 1000 0100|

	1.	Подставив 0 на место незаполненного бита, получим:

		| байт 1 | байт 2 | байт 3 | байт 4 |
		|:-----:|:-----:|:-----:|:-----:|
		| 1111 0000 | 1011 1010 | 1011 1100 | 1000 0100|

В итоге получим F0BA BC84<sub>16</sub>.
 
В таблице 6 представлены примеры кодировки символов из разных диапазонов в 1, 2, 3 и 4 словах.

### Таблица 6. Примеры кодирования символов из различных диапазонов

| Символ | Шестнадцатеричный код символа | Двоичный код символа	 | UTF-8 в двоичном виде | UTF-8 в шестнадцатеричном виде |
|:-:|:-:|:-:|:-:|:-:|
|&#x0025; | U+0025 | 100101 | 00100101 | 25 |
|&#x06AF; | U+06AF | 110 10101111 | 11011010 10101111 | DA AF |	
 &#x263a; | U+263a | 100110 00111010 | 11100010 10011000 10111010 | E2 98 BA |
 &#x10348; | U+10348 | 1 00000011 01001000 | 11110000 10010000 10001101 10001000 | F0 90 8D 88 |

Для того, чтоб показать, что файл или поток записан в кодировке **UTF-8** в его начале ставится маркер последовательности байтов **BOM** из трех байтов: EF BB BF<sub>16</sub>.

# <a name="vs"></a>**UTF-8** vs **UTF-16**: преимущества и недостатки

Сравним два способа кодирования **UTF-8** и **UTF-16**, для этого опишем преимущества и недостатки каждого из них. 

### Преимущества **UTF-8**:

1.	Символы первой половины восьмибитной таблицы **ASCII** такие как цифры, латинские символы и 
	управляющие символы также представляются и в **UTF-8**, что обеспечивает обратную совместимость **UTF-8** с **ASCII**.

1.	**UTF-8** использует один фиксированный порядок байтов, поэтому не нужно различать **BE** и **LE**
	варианты кодировки.

1.	В файлах, закодированных с использование **UTF-8**, нет нулевых байтов, это дает экономичное 
	представление текстов и способствует обратной совместимости с **ASCII**.

1.	Самая распространенная кодировка в Интернет.

### Недостатки **UTF-8**:

1.	Кодовая точка может быть закодирована в 1, 2, 3 или 4 байтах, что усложняет алгоритмы кодировки и 
	раскодировки.

1.	Существенные затраты на маркировочные биты. Это уменьшает количество значащих бит, которые можно 
	было бы использовать. При кодировании в 4 байтах на маркировочные биты приходится более 30% (11 из 32 бит).


### Преимущества **UTF-16**:

1.	Символы из **BMP** (основной многоязычной плоскости) в **UTF-16** могут быть представлены 2 
	байтами, при этом в **UTF-8** на кодировку символов из BMP может быть затрачено от 1 до 3 байтов, поэтому кодирование с использованием **UTF-8** не всегда более экономичное. Использование фиксированных 2 байтов для текстов из **BMP** ускоряет индексирование и упрощает вычисления. Даже если в тексте присутствуют символы, кодируемые суррогатными парами, индексирование все равно выполняется быстрее.

1.	Даже если в кодируемом тексте встречаются символы не из **BMP**, для кодирования которых 
	используются суррогатные пары, код кратен 16, что позволяет использовать 16-разрядные типы для работы с **UTF-16**.

### Недостатки **UTF-16**:

1.	Использование двух вариантов длины кодирования усложняет кодировку и раскодировку.

1.	Много нулевых байтов в строках, состоящих из символов **ASCII**.

Подведем итог: общим недостатком рассмотренных кодировок является сложность алгоритмов кодирования и раскодирования, что связано с использованием кодирования переменной длины. В **UTF-16** есть всего два варианта длины кода 16 и 32 бита, поэтому для этой кодировки этот недостаток менее выражен. Другим преимуществом этого способа кодирования является быстрая индексация, что крайне важно для больших текстов. Поэтому считается, что **UTF-16** больше подходит для кодирования и хранения больших, особенно многоязычных, текстов. **UTF-8** удобно использовать для сетевых протоколов, в частности в Интернет, так как в этой кодировке не нужно отличать **BE** от **LE** и есть обратная совместимость с **ASCII**.


[unicode-org]: https://home.unicode.org
[utf16coding]: https://igriva.github.io/jekyll/update/2019/07/21/utf-16.html
[utf8coding]:  https://igriva.github.io/jekyll/update/2019/07/21/utf-8.html
[utf16-vs-utf8]: https://igriva.github.io/jekyll/update/2019/07/21/utf16_vs_utf8.html
[habr]: https://habr.com/ru/post/45489/